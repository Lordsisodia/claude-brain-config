# üß† MUSK ALGORITHM FOR CODING CONTEXTS - CRITICAL CORRECTIONS
# Special adaptations for software development where "deletion" means something different

Musk_Algorithm_Coding_Adaptation: &musk_coding |
  
  # üö® CRITICAL: When working with CODE, apply Musk Algorithm CAREFULLY
  
  ## STEP 1: MAKE REQUIREMENTS LESS DUMB (Coding Context)
  - Question: "What specific functionality does the user actually need?"
  - Question: "What problem is this code actually solving?"
  - Question: "Are we building features vs solving the core problem?"
  - ‚ö†Ô∏è  Don't question established dependencies or working code patterns
  
  ## STEP 2: DELETE UNNECESSARY PARTS (Coding Context - BE CAREFUL!)
  - üö´ DON'T DELETE: Working code, dependencies, established patterns
  - ‚úÖ DO "DELETE": Unnecessary features, over-engineering, complexity layers
  - ‚úÖ DO "DELETE": Theoretical frameworks not yet needed
  - ‚úÖ DO "DELETE": Coordination layers that don't add value
  - üéØ "Deletion" in coding = "Don't build unnecessary features"
  
  ## STEP 3: SIMPLIFY (Coding Context)
  - Choose simpler implementation approaches
  - Use existing libraries instead of building from scratch
  - Prefer straightforward code over clever abstractions
  - Write readable code over performance optimizations (until proven needed)
  
  ## STEP 4: ACCELERATE (Coding Context)
  - Optimize only proven bottlenecks
  - Use profiling to identify actual slow parts
  - Don't prematurely optimize
  
  ## STEP 5: AUTOMATE (Coding Context)
  - Script repetitive development tasks
  - Automate testing and deployment
  - Don't automate what doesn't work manually first

Coding_Safe_Deletion_Guidelines: &safe_deletion |
  
  # üõ°Ô∏è SAFE "DELETION" IN CODING CONTEXTS
  
  ## WHAT TO "DELETE" (Don't Build):
  - Unnecessary abstraction layers
  - Premature optimization
  - Features not yet requested
  - Complex frameworks for simple problems
  - Orchestration before individual components work
  - Configuration systems for hardcoded values
  - Monitoring for systems that don't exist yet
  
  ## WHAT NEVER TO DELETE:
  - Working code that users depend on
  - Established dependencies
  - Error handling and validation
  - Security measures
  - Data persistence
  - Backup and recovery mechanisms
  
  ## SAFE APPROACH:
  1. Build minimum viable implementation first
  2. Test that it works
  3. Then decide what additional features are actually needed
  4. Refactor for simplicity, not complexity

Code_First_Principles_Thinking: &code_first_principles |
  
  # üß¨ FIRST PRINCIPLES FOR CODE
  
  ## FUNDAMENTAL QUESTIONS:
  1. "What is the user trying to accomplish?" (not what they asked for)
  2. "What's the simplest code that solves this problem?"
  3. "Am I solving the right problem or just building features?"
  4. "Would a simple script work instead of a framework?"
  5. "Am I building this because it's needed or because it's interesting?"
  
  ## REASONING FROM BASICS:
  - Start with working code, not architecture
  - Prove functionality before adding sophistication  
  - Use standard libraries instead of custom solutions
  - Write obvious code before clever code
  - Solve the actual problem, not the general case